{
  "app_id": "3189490",
  "name": "dsvsdfweich dsd sf      fffffffffffffffff",
  "description": "This app performdddddddddddnfklsvnnnnnnnnnnnnnnnnnnnnnnn v dklv              kl vdklv dklllllv lks numerical integration using one of the traditional methods",
  "author": {
    "id": "0a5be9a2-d6d5-47a9-a71a-90ba682d920a",
    "username": "You",
    "image": "https://source.unsplash.com/random"
  },
  "status": "draft",
  "permission": "public",
  "category": { "id": 3, "name": "Civil", "description": "" },
  "tags": [{ "id": 12, "name": "Ds" }],
  "created_on": "2022-03-09T18:54:14.578808-07:00",
  "updated_at": "2022-03-26T10:43:57.333397-06:00",
  "primary_image": "http://localhost:8000/media/apps/default/primary_image_8.jpg",
  "favicon_image": "http://localhost:8000/media/apps/default/favicon.png",
  "secondary_images": [],
  "input_sections": {
    "order": ["section-0", "section-1"],
    "section-0": {
      "id": "section-0",
      "title": "Function and Bounds",
      "inputs_order": ["input_0", "input_1", "input_2"]
    },
    "section-1": {
      "id": "section-1",
      "title": "Integration",
      "inputs_order": ["input_3", "input_4"]
    }
  },
  "input_inputs": {
    "input_0": {
      "id": "input_0",
      "component": "TextInput",
      "props": {
        "name": "func",
        "label": "Function expression (input a function in variable x)",
        "defaultValue": "x^2+sin(x)",
        "placeholder": "",
        "required": true,
        "readOnly": false,
        "minLength": 0,
        "maxLength": 10000,
        "pattern": ".*"
      }
    },
    "input_1": {
      "id": "input_1",
      "component": "NumberInput",
      "props": {
        "name": "a",
        "label": "Lower Bound (a)",
        "units": "",
        "defaultValue": -10,
        "required": true,
        "readOnly": false,
        "step": 0.001,
        "min": -10000,
        "max": 10000
      }
    },
    "input_2": {
      "id": "input_2",
      "component": "NumberInput",
      "props": {
        "name": "b",
        "label": "Upper Bound",
        "units": "",
        "defaultValue": 10,
        "required": true,
        "readOnly": false,
        "step": 0.001,
        "min": -10000,
        "max": 10000
      }
    },
    "input_3": {
      "id": "input_3",
      "component": "SingleSelect",
      "props": {
        "name": "method",
        "label": "Integration Method",
        "options": [
          "Rectangle Method 1 (Left Corner)",
          "Rectangle Method 2 (Midpoint)",
          "Rectangle Method 3 (Right Corner)",
          "Trapezoid Rule",
          "Simpson's One Third Rule",
          "Simpson's Three Eightth Rule"
        ],
        "required": true,
        "disabled": false
      }
    },
    "input_4": {
      "id": "input_4",
      "component": "NumberInput",
      "props": {
        "name": "n",
        "label": "Number of Intervals",
        "units": "",
        "defaultValue": 2,
        "required": true,
        "readOnly": false,
        "step": 1,
        "min": 1,
        "max": 10000
      }
    }
  },
  "input_layout": {},
  "code": "import sympy as sp\r\nfrom scipy.integrate import quad\r\nimport matplotlib.pyplot as plt\r\nimport numpy as np\r\nimport base64\r\nimport io\r\nimport math\r\n\r\n#This function is used to create an image from the plot created using matplotlib.plt\r\ndef plt_show(plt, width=500, dpi=100):\r\n    # Converts matplotlib plt to data string\r\n    # dpi (dots per inch) is the resolution of the image\r\n    # width is width of image in pixels\r\n    bytes = io.BytesIO()\r\n    plt.savefig(bytes, format='png', dpi=dpi)  # Save as png image\r\n    plt.close()\r\n    bytes.seek(0)\r\n    base64_string = \"data:image/png;base64,\" + \\\r\n        base64.b64encode(bytes.getvalue()).decode(\"utf-8\")\r\n    return \"<img src='\" + base64_string + \"' width='\" + str(width) + \"'>\"\r\n\r\n#The following functions calculate the integrals and the coordinates for plotting the visual curves representing the integration\r\ndef I1(f, a, b, n):\r\n  h = (b - a)/n\r\n  x_coor=[]\r\n  y_coor=[] \r\n  i=0;\r\n  while i< int(n):\r\n    x_coor.extend([(a+i*h),(a+(i+1)*h)])\r\n    y_coor.extend([f(a+i*h),f(a+(i)*h)])\r\n    i=i+1\r\n  return [sum([f(a + i*h)*h for i in range(int(n))]),x_coor,y_coor]\r\ndef I2(f, a, b, n):\r\n  h = (b - a)/n\r\n  x_coor=[]\r\n  y_coor=[] \r\n  i=0;\r\n  while i< int(n):\r\n    x_coor.extend([(a+i*h),(a+(i+1)*h)])\r\n    y_coor.extend([f(a+(i+0.5)*h),f(a+(i+0.5)*h)])\r\n    i=i+1\r\n  return [sum([f(a + (i + 1/2)*h)*h for i in range(int(n))]),x_coor,y_coor]\r\ndef I3(f, a, b, n):\r\n  h = (b - a)/n\r\n  x_coor=[]\r\n  y_coor=[] \r\n  i=0;\r\n  while i< int(n):\r\n    x_coor.extend([(a+i*h),(a+(i+1)*h)])\r\n    y_coor.extend([f(a+(i+1)*h),f(a+(i+1)*h)])\r\n    i=i+1\r\n  return [sum([f(a + (i + 1)*h)*h for i in range(int(n))]),x_coor,y_coor]\r\ndef IT(f, a, b, n):\r\n  h = (b - a)/n\r\n  x_coor=[]\r\n  y_coor=[] \r\n  i=0;\r\n  while i< int(n):\r\n    x_coor.extend([(a+i*h),(a+(i+1)*h)])\r\n    y_coor.extend([f(a+(i)*h),f(a+(i+1)*h)])\r\n    i=i+1\r\n  return [sum([(f(a + i*h) + f(a + (i + 1)*h))*h/2 for i in range(int(n))]),x_coor,y_coor]\r\ndef IS1(f, a, b, n):\r\n  h = (b - a)/2/n\r\n  x_coor=[]\r\n  y_coor=[] \r\n  i=0;\r\n  while i< int(n):\r\n    x1=np.linspace((a+2*i*h),(a+(i+1)*2*h))\r\n    xi1=a+i*2*h\r\n    xi=a+(i+1)*2*h\r\n    xmi=a+(i+0.5)*2*h\r\n    y1=f(xi1)*(x1-xmi)*(x1-xi)/2/h**2-f(xmi)*(x1-xi1)*(x1-xi)/h**2+f(xi)*(x1-xi1)*(x1-xmi)/2/h**2\r\n    x_coor.extend(x1)\r\n    y_coor.extend(y1)\r\n    i=i+1\r\n  return [h/3*sum([(f(a + (2*i)*h) + 4*f(a + (2*i + 1)*h) + f(a + (2*i + 2)*h)) for i in range(int(n))]),x_coor,y_coor]\r\ndef IS2(f, a, b, n):\r\n  h = (b - a)/3/n\r\n  x_coor=[]\r\n  y_coor=[] \r\n  i=0;\r\n  while i< int(n):\r\n    x1=np.linspace((a+i*3*h),(a+(i+1)*3*h))\r\n    xi1=a+i*3*h\r\n    xli=xi1+h\r\n    xri=xli+h\r\n    xi=xri+h\r\n    #y1=x1**2+2.0\r\n    #print(y1)\r\n    y1=f(xi1)*(x1-xli)*(x1-xri)*(x1-xi)/-6/h**3+f(xli)*(x1-xi1)*(x1-xri)*(x1-xi)/2/h**3-f(xri)*(x1-xi1)*(x1-xli)*(x1-xi)/2/h**3+f(xi)*(x1-xi1)*(x1-xli)*(x1-xri)/6/h**3\r\n    x_coor.extend(x1)\r\n    y_coor.extend(y1)\r\n    i=i+1\r\n  return [3*h/8*sum([(f(a + (3*i)*h) + 3*f(a + (3*i + 1)*h) + 3*f(a + (3*i + 2)*h) + f(a + (3*i + 3)*h)) for i in range(int(n))]),x_coor,y_coor]\r\n\r\n#The following function is used to select the appropriate case\r\ndef switch(Method,f,a,b,n):\r\n  tester={\r\n\"Rectangle Method 1 (Left Corner)\":I1,\r\n\"Rectangle Method 2 (Midpoint)\":I2,\r\n\"Rectangle Method 3 (Right Corner)\":I3,\r\n\"Trapezoid Rule\":IT,\r\n\"Simpson's One Third Rule\":IS1,\r\n\"Simpson's Three Eightth Rule\":IS2,\r\n  }\r\n  return tester.get(Method,\"none found\")(f,a,b,n)\r\n\r\n#The following function is used for rounding to significant digits. \r\ndef rounds(a_number,significant_digits):\r\n  small_value=1.0e-9\r\n  try:\r\n    rounded_number =  round(a_number, significant_digits - int(math.floor(math.log10(max(abs(a_number),abs(small_value))))) - 1)\r\n  except:\r\n    rounded_number = \"N/A\"\r\n  return rounded_number\r\n\r\n\r\n#This is the main function\r\ndef main(inputs):\r\n    f=inputs['func']\r\n    a=inputs['a']\r\n    b=inputs['b']\r\n    Method=inputs['method']\r\n    n=inputs['n']\r\n    Err=False\r\n    img=False\r\n    Err2=False\r\n    try:\r\n        g=sp.sympify(f)\r\n    except:\r\n        Err=True\r\n    #Here I use sympy plot which is has matplotlib as its backend.\r\n    if not Err:\r\n        x=sp.symbols('x')\r\n        try:\r\n            sp.plot(g,(x,a,b))\r\n            img=plt_show(plt,500)\r\n            f=sp.lambdify(x,g)\r\n        except:\r\n            Err2=True\r\n    if not Err and not Err2:\r\n        res,err=quad(f,a,b)\r\n        #Exact=\"The numerical result is {:f} (+-{:g})\".format(res, err))\r\n        #print(switch(Method,f,a,b,n))\r\n        Integration,x_coor,y_coor=switch(Method,f,a,b,n)\r\n        percent=rounds((Integration-res)/res*100,3)\r\n        plt.fill_between(x_coor,0,y_coor,color='black',facecolor='orange')\r\n        x1=np.linspace(a,b)\r\n        plt.plot(x1,f(x1))\r\n        curve=plt_show(plt,500)\r\n    else:\r\n        print(\"error\")\r\n    return {\"plot\":img, \"equation\":g,\"Error\":Err,\"ErrorPlot\":Err2,\"a\":a,\"b\":b,\"n\":n,\"Method\":Method,\"Integration\":rounds(Integration,5),\"Res\":res,\"Err\":err,\"Percent\":percent,\"Curve\":curve}",
  "theme": "light",
  "output_html": "<p><strong style=\"color: black;\">{% if outputs.Error %}</strong></p><p>Please Enter a valid expression in <span class=\"ql-formula\" data-value=\"x\">﻿<span contenteditable=\"false\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.43056em; vertical-align: 0em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span>﻿</span></p><p><strong style=\"color: black;\">{% elif outputs.ErrorPlot %}</strong></p><p>Function could not be plotted. Please enter a valid expression in variable <span class=\"ql-formula\" data-value=\"x\">﻿<span contenteditable=\"false\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.43056em; vertical-align: 0em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span>﻿</span></p><p><strong style=\"color: black;\">{% else %}</strong></p><p>The following figure provides the plot for the function f(x)={{outputs.equation}} between {{outputs.a}} and {{outputs.b}}</p><p>{{outputs.plot|safe}}</p><p>The python scipy package provides an accurate estimate of the ingral which is {{outputs.Res}}+/-{{outputs.Err}}</p><p>Using {{outputs.Method}}, numerical integration with {{outputs.n}} intervals yields {{outputs.Integration}}, which is {{outputs.Percent}}% different from the scipy result.</p><p>The following curve provides the plot of the function and the area calculated according to {{outputs.Method}}:</p><p>{{outputs.Curve|safe}}{{ outputs.Percent }}</p><p><strong style=\"color: black;\">{% endif %}</strong></p>",
  "docs_html": "<p>The numerical integration follows the exaplanation on the online notes here:</p><p><a href=\"https://engcourses-uofa.ca/books/numericalanalysis/numerical-integration/introduction/\" rel=\"noopener noreferrer\" target=\"_blank\">https://engcourses-uofa.ca/books/numericalanalysis/numerical-integration/introduction/</a></p><p><br></p><p><br></p><p><br></p><p>The code used:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">import&nbsp;sympy&nbsp;as&nbsp;sp\r\nfrom&nbsp;scipy.integrate&nbsp;import&nbsp;quad\r\nimport&nbsp;matplotlib.pyplot&nbsp;as&nbsp;plt\r\nimport&nbsp;numpy&nbsp;as&nbsp;np\r\nimport&nbsp;base64\r\nimport&nbsp;io\r\nimport&nbsp;math\r\n\r\n\r\n#This&nbsp;function&nbsp;is&nbsp;used&nbsp;to&nbsp;create&nbsp;an&nbsp;image&nbsp;from&nbsp;the&nbsp;plot&nbsp;created&nbsp;using&nbsp;matplotlib.plt\r\ndef&nbsp;plt_show(plt,&nbsp;width=500,&nbsp;dpi=100):\r\n&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Converts&nbsp;matplotlib&nbsp;plt&nbsp;to&nbsp;data&nbsp;string\r\n&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;dpi&nbsp;(dots&nbsp;per&nbsp;inch)&nbsp;is&nbsp;the&nbsp;resolution&nbsp;of&nbsp;the&nbsp;image\r\n&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;width&nbsp;is&nbsp;width&nbsp;of&nbsp;image&nbsp;in&nbsp;pixels\r\n&nbsp;&nbsp;&nbsp;&nbsp;bytes&nbsp;=&nbsp;io.BytesIO()\r\n&nbsp;&nbsp;&nbsp;&nbsp;plt.savefig(bytes,&nbsp;format='png',&nbsp;dpi=dpi)&nbsp;&nbsp;#&nbsp;Save&nbsp;as&nbsp;png&nbsp;image\r\n&nbsp;&nbsp;&nbsp;&nbsp;plt.close()\r\n&nbsp;&nbsp;&nbsp;&nbsp;bytes.seek(0)\r\n&nbsp;&nbsp;&nbsp;&nbsp;base64_string&nbsp;=&nbsp;\"data:image/png;base64,\"&nbsp;+&nbsp;\\\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;base64.b64encode(bytes.getvalue()).decode(\"utf-8\")\r\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;\"&lt;img&nbsp;src='\"&nbsp;+&nbsp;base64_string&nbsp;+&nbsp;\"'&nbsp;width='\"&nbsp;+&nbsp;str(width)&nbsp;+&nbsp;\"'&gt;\"\r\n\r\n\r\n#The&nbsp;following&nbsp;functions&nbsp;calculate&nbsp;the&nbsp;integrals&nbsp;and&nbsp;the&nbsp;coordinates&nbsp;for&nbsp;plotting&nbsp;the&nbsp;visual&nbsp;curves&nbsp;representing&nbsp;the&nbsp;integration\r\ndef&nbsp;I1(f,&nbsp;a,&nbsp;b,&nbsp;n):\r\n&nbsp;&nbsp;h&nbsp;=&nbsp;(b&nbsp;-&nbsp;a)/n\r\n&nbsp;&nbsp;x_coor=[]\r\n&nbsp;&nbsp;y_coor=[]&nbsp;\r\n&nbsp;&nbsp;i=0;\r\n&nbsp;&nbsp;while&nbsp;i&lt;&nbsp;int(n):\r\n&nbsp;&nbsp;&nbsp;&nbsp;x_coor.extend([(a+i*h),(a+(i+1)*h)])\r\n&nbsp;&nbsp;&nbsp;&nbsp;y_coor.extend([f(a+i*h),f(a+(i)*h)])\r\n&nbsp;&nbsp;&nbsp;&nbsp;i=i+1\r\n&nbsp;&nbsp;return&nbsp;[sum([f(a&nbsp;+&nbsp;i*h)*h&nbsp;for&nbsp;i&nbsp;in&nbsp;range(int(n))]),x_coor,y_coor]\r\ndef&nbsp;I2(f,&nbsp;a,&nbsp;b,&nbsp;n):\r\n&nbsp;&nbsp;h&nbsp;=&nbsp;(b&nbsp;-&nbsp;a)/n\r\n&nbsp;&nbsp;x_coor=[]\r\n&nbsp;&nbsp;y_coor=[]&nbsp;\r\n&nbsp;&nbsp;i=0;\r\n&nbsp;&nbsp;while&nbsp;i&lt;&nbsp;int(n):\r\n&nbsp;&nbsp;&nbsp;&nbsp;x_coor.extend([(a+i*h),(a+(i+1)*h)])\r\n&nbsp;&nbsp;&nbsp;&nbsp;y_coor.extend([f(a+(i+0.5)*h),f(a+(i+0.5)*h)])\r\n&nbsp;&nbsp;&nbsp;&nbsp;i=i+1\r\n&nbsp;&nbsp;return&nbsp;[sum([f(a&nbsp;+&nbsp;(i&nbsp;+&nbsp;1/2)*h)*h&nbsp;for&nbsp;i&nbsp;in&nbsp;range(int(n))]),x_coor,y_coor]\r\ndef&nbsp;I3(f,&nbsp;a,&nbsp;b,&nbsp;n):\r\n&nbsp;&nbsp;h&nbsp;=&nbsp;(b&nbsp;-&nbsp;a)/n\r\n&nbsp;&nbsp;x_coor=[]\r\n&nbsp;&nbsp;y_coor=[]&nbsp;\r\n&nbsp;&nbsp;i=0;\r\n&nbsp;&nbsp;while&nbsp;i&lt;&nbsp;int(n):\r\n&nbsp;&nbsp;&nbsp;&nbsp;x_coor.extend([(a+i*h),(a+(i+1)*h)])\r\n&nbsp;&nbsp;&nbsp;&nbsp;y_coor.extend([f(a+(i+1)*h),f(a+(i+1)*h)])\r\n&nbsp;&nbsp;&nbsp;&nbsp;i=i+1\r\n&nbsp;&nbsp;return&nbsp;[sum([f(a&nbsp;+&nbsp;(i&nbsp;+&nbsp;1)*h)*h&nbsp;for&nbsp;i&nbsp;in&nbsp;range(int(n))]),x_coor,y_coor]\r\ndef&nbsp;IT(f,&nbsp;a,&nbsp;b,&nbsp;n):\r\n&nbsp;&nbsp;h&nbsp;=&nbsp;(b&nbsp;-&nbsp;a)/n\r\n&nbsp;&nbsp;x_coor=[]\r\n&nbsp;&nbsp;y_coor=[]&nbsp;\r\n&nbsp;&nbsp;i=0;\r\n&nbsp;&nbsp;while&nbsp;i&lt;&nbsp;int(n):\r\n&nbsp;&nbsp;&nbsp;&nbsp;x_coor.extend([(a+i*h),(a+(i+1)*h)])\r\n&nbsp;&nbsp;&nbsp;&nbsp;y_coor.extend([f(a+(i)*h),f(a+(i+1)*h)])\r\n&nbsp;&nbsp;&nbsp;&nbsp;i=i+1\r\n&nbsp;&nbsp;return&nbsp;[sum([(f(a&nbsp;+&nbsp;i*h)&nbsp;+&nbsp;f(a&nbsp;+&nbsp;(i&nbsp;+&nbsp;1)*h))*h/2&nbsp;for&nbsp;i&nbsp;in&nbsp;range(int(n))]),x_coor,y_coor]\r\ndef&nbsp;IS1(f,&nbsp;a,&nbsp;b,&nbsp;n):\r\n&nbsp;&nbsp;h&nbsp;=&nbsp;(b&nbsp;-&nbsp;a)/2/n\r\n&nbsp;&nbsp;x_coor=[]\r\n&nbsp;&nbsp;y_coor=[]&nbsp;\r\n&nbsp;&nbsp;i=0;\r\n&nbsp;&nbsp;while&nbsp;i&lt;&nbsp;int(n):\r\n&nbsp;&nbsp;&nbsp;&nbsp;x1=np.linspace((a+2*i*h),(a+(i+1)*2*h))\r\n&nbsp;&nbsp;&nbsp;&nbsp;xi1=a+i*2*h\r\n&nbsp;&nbsp;&nbsp;&nbsp;xi=a+(i+1)*2*h\r\n&nbsp;&nbsp;&nbsp;&nbsp;xmi=a+(i+0.5)*2*h\r\n&nbsp;&nbsp;&nbsp;&nbsp;y1=f(xi1)*(x1-xmi)*(x1-xi)/2/h**2-f(xmi)*(x1-xi1)*(x1-xi)/h**2+f(xi)*(x1-xi1)*(x1-xmi)/2/h**2\r\n&nbsp;&nbsp;&nbsp;&nbsp;x_coor.extend(x1)\r\n&nbsp;&nbsp;&nbsp;&nbsp;y_coor.extend(y1)\r\n&nbsp;&nbsp;&nbsp;&nbsp;i=i+1\r\n&nbsp;&nbsp;return&nbsp;[h/3*sum([(f(a&nbsp;+&nbsp;(2*i)*h)&nbsp;+&nbsp;4*f(a&nbsp;+&nbsp;(2*i&nbsp;+&nbsp;1)*h)&nbsp;+&nbsp;f(a&nbsp;+&nbsp;(2*i&nbsp;+&nbsp;2)*h))&nbsp;for&nbsp;i&nbsp;in&nbsp;range(int(n))]),x_coor,y_coor]\r\ndef&nbsp;IS2(f,&nbsp;a,&nbsp;b,&nbsp;n):\r\n&nbsp;&nbsp;h&nbsp;=&nbsp;(b&nbsp;-&nbsp;a)/3/n\r\n&nbsp;&nbsp;x_coor=[]\r\n&nbsp;&nbsp;y_coor=[]&nbsp;\r\n&nbsp;&nbsp;i=0;\r\n&nbsp;&nbsp;while&nbsp;i&lt;&nbsp;int(n):\r\n&nbsp;&nbsp;&nbsp;&nbsp;x1=np.linspace((a+i*3*h),(a+(i+1)*3*h))\r\n&nbsp;&nbsp;&nbsp;&nbsp;xi1=a+i*3*h\r\n&nbsp;&nbsp;&nbsp;&nbsp;xli=xi1+h\r\n&nbsp;&nbsp;&nbsp;&nbsp;xri=xli+h\r\n&nbsp;&nbsp;&nbsp;&nbsp;xi=xri+h\r\n&nbsp;&nbsp;&nbsp;&nbsp;#y1=x1**2+2.0\r\n&nbsp;&nbsp;&nbsp;&nbsp;#print(y1)\r\n&nbsp;&nbsp;&nbsp;&nbsp;y1=f(xi1)*(x1-xli)*(x1-xri)*(x1-xi)/-6/h**3+f(xli)*(x1-xi1)*(x1-xri)*(x1-xi)/2/h**3-f(xri)*(x1-xi1)*(x1-xli)*(x1-xi)/2/h**3+f(xi)*(x1-xi1)*(x1-xli)*(x1-xri)/6/h**3\r\n&nbsp;&nbsp;&nbsp;&nbsp;x_coor.extend(x1)\r\n&nbsp;&nbsp;&nbsp;&nbsp;y_coor.extend(y1)\r\n&nbsp;&nbsp;&nbsp;&nbsp;i=i+1\r\n&nbsp;&nbsp;return&nbsp;[3*h/8*sum([(f(a&nbsp;+&nbsp;(3*i)*h)&nbsp;+&nbsp;3*f(a&nbsp;+&nbsp;(3*i&nbsp;+&nbsp;1)*h)&nbsp;+&nbsp;3*f(a&nbsp;+&nbsp;(3*i&nbsp;+&nbsp;2)*h)&nbsp;+&nbsp;f(a&nbsp;+&nbsp;(3*i&nbsp;+&nbsp;3)*h))&nbsp;for&nbsp;i&nbsp;in&nbsp;range(int(n))]),x_coor,y_coor]\r\n\r\n\r\n#The&nbsp;following&nbsp;function&nbsp;is&nbsp;used&nbsp;to&nbsp;select&nbsp;the&nbsp;appropriate&nbsp;case\r\ndef&nbsp;switch(Method,f,a,b,n):\r\n&nbsp;&nbsp;tester={\r\n\"Rectangle&nbsp;Method&nbsp;1&nbsp;(Left&nbsp;Corner)\":I1,\r\n\"Rectangle&nbsp;Method&nbsp;2&nbsp;(Midpoint)\":I2,\r\n\"Rectangle&nbsp;Method&nbsp;3&nbsp;(Right&nbsp;Corner)\":I3,\r\n\"Trapezoid&nbsp;Rule\":IT,\r\n\"Simpson's&nbsp;One&nbsp;Third&nbsp;Rule\":IS1,\r\n\"Simpson's&nbsp;Three&nbsp;Eightth&nbsp;Rule\":IS2,\r\n&nbsp;&nbsp;}\r\n&nbsp;&nbsp;return&nbsp;tester.get(Method,\"none&nbsp;found\")(f,a,b,n)\r\n\r\n\r\n#The&nbsp;following&nbsp;function&nbsp;is&nbsp;used&nbsp;for&nbsp;rounding&nbsp;to&nbsp;significant&nbsp;digits.&nbsp;\r\ndef&nbsp;rounds(a_number,significant_digits):\r\n&nbsp;&nbsp;small_value=1.0e-9\r\n&nbsp;&nbsp;try:\r\n&nbsp;&nbsp;&nbsp;&nbsp;rounded_number&nbsp;=&nbsp;&nbsp;round(a_number,&nbsp;significant_digits&nbsp;-&nbsp;int(math.floor(math.log10(max(abs(a_number),abs(small_value)))))&nbsp;-&nbsp;1)\r\n&nbsp;&nbsp;except:\r\n&nbsp;&nbsp;&nbsp;&nbsp;rounded_number&nbsp;=&nbsp;\"N/A\"\r\n&nbsp;&nbsp;return&nbsp;rounded_number\r\n\r\n\r\n\r\n#This&nbsp;is&nbsp;the&nbsp;main&nbsp;function\r\ndef&nbsp;main(inputs):\r\n&nbsp;&nbsp;&nbsp;&nbsp;f=inputs['func']\r\n&nbsp;&nbsp;&nbsp;&nbsp;a=inputs['a']\r\n&nbsp;&nbsp;&nbsp;&nbsp;b=inputs['b']\r\n&nbsp;&nbsp;&nbsp;&nbsp;Method=inputs['method']\r\n&nbsp;&nbsp;&nbsp;&nbsp;n=inputs['n']\r\n&nbsp;&nbsp;&nbsp;&nbsp;Err=False\r\n&nbsp;&nbsp;&nbsp;&nbsp;img=False\r\n&nbsp;&nbsp;&nbsp;&nbsp;Err2=False\r\n&nbsp;&nbsp;&nbsp;&nbsp;try:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g=sp.sympify(f)\r\n&nbsp;&nbsp;&nbsp;&nbsp;except:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Err=True\r\n&nbsp;&nbsp;&nbsp;&nbsp;#Here&nbsp;I&nbsp;use&nbsp;sympy&nbsp;plot&nbsp;which&nbsp;is&nbsp;has&nbsp;matplotlib&nbsp;as&nbsp;its&nbsp;backend.\r\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;Err:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x=sp.symbols('x')\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sp.plot(g,(x,a,b))\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img=plt_show(plt,500)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f=sp.lambdify(x,g)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Err2=True\r\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;Err&nbsp;and&nbsp;not&nbsp;Err2:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res,err=quad(f,a,b)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Exact=\"The&nbsp;numerical&nbsp;result&nbsp;is&nbsp;{:f}&nbsp;(+-{:g})\".format(res,&nbsp;err))\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#print(switch(Method,f,a,b,n))\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integration,x_coor,y_coor=switch(Method,f,a,b,n)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;percent=rounds((Integration-res)/res*100,3)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plt.fill_between(x_coor,0,y_coor,color='black',facecolor='orange')\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x1=np.linspace(a,b)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plt.plot(x1,f(x1))\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curve=plt_show(plt,500)\r\n&nbsp;&nbsp;&nbsp;&nbsp;else:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(\"error\")\r\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;{\"plot\":img,&nbsp;\"equation\":g,\"Error\":Err,\"ErrorPlot\":Err2,\"a\":a,\"b\":b,\"n\":n,\"Method\":Method,\"Integration\":rounds(Integration,5),\"Res\":res,\"Err\":err,\"Percent\":percent,\"Curve\":curve}\r\n</pre><p><br></p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">{% if outputs.Error %}\r\nPlease Enter a valid expression in ﻿x\r\n{% elif outputs.ErrorPlot %}\r\nFunction could not be plotted. Please enter a valid expression in variable ﻿x\r\n{% else %}\r\nThe following figure provides the plot for the function f(x)={{outputs.equation}} between {{outputs.a}} and {{outputs.b}}\r\n{{outputs.plot|safe}}\r\nThe python scipy package provides an accurate estimate of the ingral which is {{outputs.Res}}+/-{{outputs.Err}}\r\nUsing {{outputs.Method}}, numerical integration with {{outputs.n}} intervals yields {{outputs.Integration}}, which is {{outputs.Percent}}% different from the scipy result.\r\nThe following curve provides the plot of the function and the area calculated according to {{outputs.Method}}:\r\n{{outputs.Curve|safe}}\r\n{% endif %}﻿\r\n</pre><p><br></p><p><br></p><p>The output page:</p><pre class=\"ql-syntax\" spellcheck=\"false\">{% if outputs.Error %}\r\nPlease Enter a valid expression in ﻿x\r\n{% elif outputs.ErrorPlot %}\r\nFunction could not be plotted. Please enter a valid expression in variable ﻿x\r\n{% else %}\r\nThe following figure provides the plot for the function f(x)={{outputs.equation}} between {{outputs.a}} and {{outputs.b}}\r\n{{outputs.plot|safe}}\r\nThe python scipy package provides an accurate estimate of the ingral which is {{outputs.Res}}+/-{{outputs.Err}}\r\nUsing {{outputs.Method}}, numerical integration with {{outputs.n}} intervals yields {{outputs.Integration}}, which is {{outputs.Percent}}% different from the scipy result.\r\nThe following curve provides the plot of the function and the area calculated according to {{outputs.Method}}:\r\n{{outputs.Curve|safe}}\r\n{% endif %}﻿\r\n</pre>",
  "related_app": {
    "views": 6,
    "code": "import sympy as sp\r\nfrom scipy.integrate import quad\r\nimport matplotlib.pyplot as plt\r\nimport numpy as np\r\nimport base64\r\nimport io\r\nimport math\r\n\r\n#This function is used to create an image from the plot created using matplotlib.plt\r\ndef plt_show(plt, width=500, dpi=100):\r\n    # Converts matplotlib plt to data string\r\n    # dpi (dots per inch) is the resolution of the image\r\n    # width is width of image in pixels\r\n    bytes = io.BytesIO()\r\n    plt.savefig(bytes, format='png', dpi=dpi)  # Save as png image\r\n    plt.close()\r\n    bytes.seek(0)\r\n    base64_string = \"data:image/png;base64,\" + \\\r\n        base64.b64encode(bytes.getvalue()).decode(\"utf-8\")\r\n    return \"<img src='\" + base64_string + \"' width='\" + str(width) + \"'>\"\r\n\r\n#The following functions calculate the integrals and the coordinates for plotting the visual curves representing the integration\r\ndef I1(f, a, b, n):\r\n  h = (b - a)/n\r\n  x_coor=[]\r\n  y_coor=[] \r\n  i=0;\r\n  while i< int(n):\r\n    x_coor.extend([(a+i*h),(a+(i+1)*h)])\r\n    y_coor.extend([f(a+i*h),f(a+(i)*h)])\r\n    i=i+1\r\n  return [sum([f(a + i*h)*h for i in range(int(n))]),x_coor,y_coor]\r\ndef I2(f, a, b, n):\r\n  h = (b - a)/n\r\n  x_coor=[]\r\n  y_coor=[] \r\n  i=0;\r\n  while i< int(n):\r\n    x_coor.extend([(a+i*h),(a+(i+1)*h)])\r\n    y_coor.extend([f(a+(i+0.5)*h),f(a+(i+0.5)*h)])\r\n    i=i+1\r\n  return [sum([f(a + (i + 1/2)*h)*h for i in range(int(n))]),x_coor,y_coor]\r\ndef I3(f, a, b, n):\r\n  h = (b - a)/n\r\n  x_coor=[]\r\n  y_coor=[] \r\n  i=0;\r\n  while i< int(n):\r\n    x_coor.extend([(a+i*h),(a+(i+1)*h)])\r\n    y_coor.extend([f(a+(i+1)*h),f(a+(i+1)*h)])\r\n    i=i+1\r\n  return [sum([f(a + (i + 1)*h)*h for i in range(int(n))]),x_coor,y_coor]\r\ndef IT(f, a, b, n):\r\n  h = (b - a)/n\r\n  x_coor=[]\r\n  y_coor=[] \r\n  i=0;\r\n  while i< int(n):\r\n    x_coor.extend([(a+i*h),(a+(i+1)*h)])\r\n    y_coor.extend([f(a+(i)*h),f(a+(i+1)*h)])\r\n    i=i+1\r\n  return [sum([(f(a + i*h) + f(a + (i + 1)*h))*h/2 for i in range(int(n))]),x_coor,y_coor]\r\ndef IS1(f, a, b, n):\r\n  h = (b - a)/2/n\r\n  x_coor=[]\r\n  y_coor=[] \r\n  i=0;\r\n  while i< int(n):\r\n    x1=np.linspace((a+2*i*h),(a+(i+1)*2*h))\r\n    xi1=a+i*2*h\r\n    xi=a+(i+1)*2*h\r\n    xmi=a+(i+0.5)*2*h\r\n    y1=f(xi1)*(x1-xmi)*(x1-xi)/2/h**2-f(xmi)*(x1-xi1)*(x1-xi)/h**2+f(xi)*(x1-xi1)*(x1-xmi)/2/h**2\r\n    x_coor.extend(x1)\r\n    y_coor.extend(y1)\r\n    i=i+1\r\n  return [h/3*sum([(f(a + (2*i)*h) + 4*f(a + (2*i + 1)*h) + f(a + (2*i + 2)*h)) for i in range(int(n))]),x_coor,y_coor]\r\ndef IS2(f, a, b, n):\r\n  h = (b - a)/3/n\r\n  x_coor=[]\r\n  y_coor=[] \r\n  i=0;\r\n  while i< int(n):\r\n    x1=np.linspace((a+i*3*h),(a+(i+1)*3*h))\r\n    xi1=a+i*3*h\r\n    xli=xi1+h\r\n    xri=xli+h\r\n    xi=xri+h\r\n    #y1=x1**2+2.0\r\n    #print(y1)\r\n    y1=f(xi1)*(x1-xli)*(x1-xri)*(x1-xi)/-6/h**3+f(xli)*(x1-xi1)*(x1-xri)*(x1-xi)/2/h**3-f(xri)*(x1-xi1)*(x1-xli)*(x1-xi)/2/h**3+f(xi)*(x1-xi1)*(x1-xli)*(x1-xri)/6/h**3\r\n    x_coor.extend(x1)\r\n    y_coor.extend(y1)\r\n    i=i+1\r\n  return [3*h/8*sum([(f(a + (3*i)*h) + 3*f(a + (3*i + 1)*h) + 3*f(a + (3*i + 2)*h) + f(a + (3*i + 3)*h)) for i in range(int(n))]),x_coor,y_coor]\r\n\r\n#The following function is used to select the appropriate case\r\ndef switch(Method,f,a,b,n):\r\n  tester={\r\n\"Rectangle Method 1 (Left Corner)\":I1,\r\n\"Rectangle Method 2 (Midpoint)\":I2,\r\n\"Rectangle Method 3 (Right Corner)\":I3,\r\n\"Trapezoid Rule\":IT,\r\n\"Simpson's One Third Rule\":IS1,\r\n\"Simpson's Three Eightth Rule\":IS2,\r\n  }\r\n  return tester.get(Method,\"none found\")(f,a,b,n)\r\n\r\n#The following function is used for rounding to significant digits. \r\ndef rounds(a_number,significant_digits):\r\n  small_value=1.0e-9\r\n  try:\r\n    rounded_number =  round(a_number, significant_digits - int(math.floor(math.log10(max(abs(a_number),abs(small_value))))) - 1)\r\n  except:\r\n    rounded_number = \"N/A\"\r\n  return rounded_number\r\n\r\n\r\n#This is the main function\r\ndef main(inputs):\r\n    f=inputs['func']\r\n    a=inputs['a']\r\n    b=inputs['b']\r\n    Method=inputs['method']\r\n    n=inputs['n']\r\n    Err=False\r\n    img=False\r\n    Err2=False\r\n    try:\r\n        g=sp.sympify(f)\r\n    except:\r\n        Err=True\r\n    #Here I use sympy plot which is has matplotlib as its backend.\r\n    if not Err:\r\n        x=sp.symbols('x')\r\n        try:\r\n            sp.plot(g,(x,a,b))\r\n            img=plt_show(plt,500)\r\n            f=sp.lambdify(x,g)\r\n        except:\r\n            Err2=True\r\n    if not Err and not Err2:\r\n        res,err=quad(f,a,b)\r\n        #Exact=\"The numerical result is {:f} (+-{:g})\".format(res, err))\r\n        #print(switch(Method,f,a,b,n))\r\n        Integration,x_coor,y_coor=switch(Method,f,a,b,n)\r\n        percent=rounds((Integration-res)/res*100,3)\r\n        plt.fill_between(x_coor,0,y_coor,color='black',facecolor='orange')\r\n        x1=np.linspace(a,b)\r\n        plt.plot(x1,f(x1))\r\n        curve=plt_show(plt,500)\r\n    else:\r\n        print(\"error\")\r\n    return {\"plot\":img, \"equation\":g,\"Error\":Err,\"ErrorPlot\":Err2,\"a\":a,\"b\":b,\"n\":n,\"Method\":Method,\"Integration\":rounds(Integration,5),\"Res\":res,\"Err\":err,\"Percent\":percent,\"Curve\":curve}",
    "stars": 0
  },
  "views": 0,
  "stars": 0
}
